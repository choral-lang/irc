#!/bin/bash

if [[ $# -lt 1 ]]; then
    echo "Usage: $0 <id> [<init-sleep> [<sleep>]]"
    exit
fi

init_sleep=${2:-0}
sleep=${3:-0}

pipe=$(mktemp -u)
mkfifo "$pipe"
trap "rm $pipe; pkill -P $$" EXIT
echo "user$1: FIFO at $pipe"

# Keep the pipe open at all times so that the reading process doesn't receive an
# EOF. Reading from a pipe results in an EOF when no process has the pipe open
# for writing.
sleep infinity > "$pipe" &
pid_sleep=$!

# Echo whatever netcat receives.
while IFS= read -r line; do
    echo "recv: user$1: $line"
done < <(nc localhost 8667 < "$pipe") &
pid_nc=$!
sleep "$init_sleep"

echo "user$1: Join #stress"
cat > "$pipe" <<EOF
NICK user$1
USER user$1 0 * user$1
JOIN #stress
EOF
sleep "$sleep"

echo "user$1: Write 1"
cat > "$pipe" <<EOF
PRIVMSG #stress :Hi from user$1, how are you?
EOF
sleep "$sleep"

echo "user$1: Write 2"
cat > "$pipe" <<EOF
PRIVMSG #stress :user$1 says they're good, thanks!
EOF
sleep "$sleep"

echo "user$1: Write 3"
cat > "$pipe" <<EOF
PRIVMSG #stress :See you later, user$1!
EOF
sleep "$sleep"

echo "user$1: Quit"
cat > "$pipe" <<EOF
QUIT :Bye from user$1!
EOF

kill "$pid_sleep"
wait "$pid_nc"
echo "user$1: Exit"
